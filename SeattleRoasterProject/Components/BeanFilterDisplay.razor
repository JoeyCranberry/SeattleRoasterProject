@inject BeanFilterService filterServ
@inject RoasterService roasterServ

<div class="row mb-3">
	<div class="d-flex justify-content-center px-0">
		<div class="row justify-content-around">
			<div class="col-9 col-sm-auto px-0 mx-0">
				<EditForm id="searchForm" Model="@filter" class="form-text rounded">
					<div class="input-group">
						<div class="form-outline">
							<InputText id="inTextSearch" @bind-Value="filter.SearchTerms" placeholder="@GetRandomSearchSuggestion()" @onkeyup="CheckEnterOnSearch" class="form-control"></InputText>
						</div>
						<button id="searchButton" type="button" class="btn btn-primary py-0" @onclick="ApplyFilter">
							<div class="d-flex align-content-center">
								<span class="bi bi-search"></span>
							</div>
						</button>
					</div>
				</EditForm>
			</div>

			<div class="col-1 px-0 mx-0">
				<BeanListingSortSelector OnSortChanged="HandleSortChanged"></BeanListingSortSelector>
			</div>
		</div>
	</div>
</div>

@code {
	[Parameter]
	public EventCallback<BeanFilter> OnBeanFilterSearch { get; set; }
	[Parameter]
	public EventCallback<SortMethod> OnSortChanged { get; set; }

	[Parameter]
	public EnviromentSettings.Enviroment CurEnviroment { get; set; }

	public void SetSearchText(string searchTerms)
	{
		filter.SearchTerms = searchTerms;
	}

	private FilterModel filter = new FilterModel();

	private List<RoasterModel>? allRoasters;

	public class FilterModel
	{
		public string SearchTerms { get; set; } = String.Empty;
		public string SelectedRoasterId { get; set; } = String.Empty;
	}

	protected override async Task OnInitializedAsync()
	{
		allRoasters = await roasterServ.GetAllRoasters();
	}

	private async Task CheckEnterOnSearch(KeyboardEventArgs e)
	{
		if (e.Code == "Enter" || e.Code == "NumpadEnter")
		{
			await ApplyFilter();
		}
	}

	public async Task ApplyFilter()
	{
		await OnBeanFilterSearch.InvokeAsync(await BuildFilter(filter));
	}

	private async Task<BeanFilter> BuildFilter(FilterModel model)
	{
		if (allRoasters != null)
		{
			return await filterServ.BuildFilterFromSearchTerms(model.SearchTerms, allRoasters, CurEnviroment);
		}
		else
		{
			return new BeanFilter
			{
				IsExcluded = new FilterValueBool(true, false),
				IsInStock = new FilterValueBool(true, true),
				ValidRoasters = CurEnviroment == EnviromentSettings.Enviroment.DEVELOPMENT ? new FilterList<string>(false, new List<string>()) : new FilterList<string>(true, allRoasters.Where(r => r.RecievedPermission).Select(r => r.Id).ToList())
			};
		}
	}

	private string GetRandomSearchSuggestion()
	{
		List<string> processTerms = new List<string>() { "washed", "natural", "wet hulled", "honey" };
		List<string> roastTerms = new List<string>() { "light", "medium", "dark" };
		List<string> countryTerm = new List<string>();
		foreach (SourceCountry country in Enum.GetValues<SourceCountry>())
		{
			if (country != SourceCountry.UNKNOWN)
			{
				countryTerm.Add(BeanOrigin.GetCountryDemonym(country));
			}
		}

		List<string> otherTerms = new List<string>() { "single origin", "blend", "certified organic", "fair trade", "direct trade", "decaf", "caffeinated" };

		Random random = new Random();
		List<string> randomTerms = new List<string>();

		randomTerms.Add(otherTerms[random.Next(otherTerms.Count)]);

		if (random.Next(2) == 0)
		{
			randomTerms.Add(processTerms[random.Next(processTerms.Count)]);
		}
		else
		{
			randomTerms.Add(roastTerms[random.Next(roastTerms.Count)] + " roast");
		}

		randomTerms.Add(countryTerm[random.Next(countryTerm.Count)]);

		return "search for a.. " + String.Join(" ", randomTerms);
	}

	private async Task HandleSortChanged(SortMethod method)
	{
		await OnSortChanged.InvokeAsync(method);
	}
}
