@inject BeanFilterService filterServ
@inject RoasterService roasterServ

<div class="row mb-3">
	<div class="d-flex justify-content-center">
		<EditForm Model="@filter" class="form-text rounded" style="width=50vw;">
			<div class="input-group">
				<div class="form-outline">
					<InputText @bind-Value="filter.SearchTerms" placeholder="@GetRandomSearchSuggestion()" @onkeyup="CheckEnterOnSearch" style="width:40vw;height:2rem" class="form-control"></InputText>
				</div>
				<button type="button" class="btn btn-primary py-0" style="height:2rem;" @onclick="ApplyFilter">
					<div class="d-flex align-content-center">
						<span class="bi bi-search me-2"></span>Search Beans
					</div>
				</button>
			</div>
		</EditForm>
		<BeanListingSortSelector OnSortChanged="HandleSortChanged"></BeanListingSortSelector>
	</div>
</div>

@code {
	[Parameter]
	public EventCallback<BeanFilter> OnBeanFilterSearch { get; set; }
	[Parameter]
	public EventCallback<SortMethod> OnSortChanged { get; set; }

	private FilterModel filter = new FilterModel();

	private Dictionary<string, string> RoasterIdAndNames;

	public class FilterModel
	{
		public string SearchTerms { get; set; } = String.Empty;
		public string SelectedRoasterId { get; set; } = String.Empty;
	}

	protected override async Task OnInitializedAsync()
	{
		RoasterIdAndNames = new();

		var roasters = await roasterServ.GetAllRoasters();
		foreach(RoasterModel roaster in roasters)
		{
			RoasterIdAndNames.Add(roaster.Id, roaster.Name);
		}
	}

	private async Task CheckEnterOnSearch(KeyboardEventArgs e)
	{
		if (e.Code == "Enter" || e.Code == "NumpadEnter")
		{
			await ApplyFilter();
		}
	}

	public async Task ApplyFilter()
	{
		await OnBeanFilterSearch.InvokeAsync(await BuildFilter(filter));
	}

	private async Task<BeanFilter> BuildFilter(FilterModel model)
	{
		return await filterServ.BuildFilterFromSearchTerms(model.SearchTerms, RoasterIdAndNames);
	}

	private string GetRandomSearchSuggestion()
	{
		List<string> processTerms = new List<string>() {"washed", "natural", "wet hulled", "honey"};
		List<string> roastTerms = new List<string>() { "light", "medium", "dark" };
		List<string> countryTerm = new List<string>();
		foreach(SourceCountry country in Enum.GetValues<SourceCountry>())
		{
			if (country != SourceCountry.UNKNOWN)
			{
				countryTerm.Add(BeanOrigin.GetCountryDemonym(country));
			}
		}

		List<string> otherTerms = new List<string>() { "single origin", "blend", "certified organic", "fair trade", "direct trade", "decaf", "caffeinated" };

		Random random = new Random();
		List<string> randomTerms = new List<string>();

		randomTerms.Add(otherTerms[random.Next(otherTerms.Count)]);

		if(random.Next(2) == 0)
		{
			randomTerms.Add(processTerms[random.Next(processTerms.Count)]);
		}
		else
		{
			randomTerms.Add(roastTerms[random.Next(roastTerms.Count)] + " roast");
		}

		randomTerms.Add(countryTerm[random.Next(countryTerm.Count)]);

		return "search for a.. " +  String.Join(" ", randomTerms);
	}

	private async Task HandleSortChanged(SortMethod method)
	{
		await OnSortChanged.InvokeAsync(method);
	}
}
